### 一、题目

给你一个大小为 m x n 的二进制网格 grid 。网格表示一个地图，其中，0 表示水，1 表示陆地。最初，grid 中的所有单元格都是水单元格（即，所有单元格都是 0）。

可以通过执行 addLand 操作，将某个位置的水转换成陆地。给你一个数组 positions ，其中 positions[i] = [ri, ci] 是要执行第 i 次操作的位置 (ri, ci) 。

返回一个整数数组 answer ，其中 answer[i] 是将单元格 (ri, ci) 转换为陆地后，地图中岛屿的数量。

岛屿 的定义是被「水」包围的「陆地」，通过水平方向或者垂直方向上相邻的陆地连接而成。你可以假设地图网格的四边均被无边无际的「水」所包围。

示例 1：

![](https://assets.leetcode.com/uploads/2021/03/10/tmp-grid.jpg)

输入：m = 3, n = 3, positions = [[0,0],[0,1],[1,2],[2,1]]
输出：[1,1,2,3]
解释：
起初，二维网格 grid 被全部注入「水」。（0 代表「水」，1 代表「陆地」）
- 操作 #1：addLand(0, 0) 将 grid[0][0] 的水变为陆地。此时存在 1 个岛屿。
- 操作 #2：addLand(0, 1) 将 grid[0][1] 的水变为陆地。此时存在 1 个岛屿。
- 操作 #3：addLand(1, 2) 将 grid[1][2] 的水变为陆地。此时存在 2 个岛屿。
- 操作 #4：addLand(2, 1) 将 grid[2][1] 的水变为陆地。此时存在 3 个岛屿。

示例 2：

输入：m = 1, n = 1, positions = [[0,0]]
输出：[1]

 

提示：

    1 <= m, n, positions.length <= 104
    1 <= m * n <= 104
    positions[i].length == 2
    0 <= ri < m
    0 <= ci < n

### 二、问题分析

看问题的同时脑海里要有一个动图。这个问题的难点在于处理合并区域。

我们在何种情况下可以合并区域？应该如何合并？

#### 2.1. 哪种情况下可以合并区域

首先它得是个区域吧，哈哈哈哈。

那就可以这样想：每有一块陆地加进来时先让区域块的总数加一，然后再判断下这个点的四周有没有陆地。只有当四周有陆地时才可能触发合并操作（读者先把这个操作看作黑盒、具体操作之后再说）。

#### 2.2. 如何合并

其实这就是并查集的操作了。当两个点的父节点不是同一个时让一个父节点变为另一个父节点的父节点。

#### 2.3. 代码

```cpp
//当两个陆地相连在一起时可能 count--
//每有一个新陆地时加1   将它与四周比较下:如果能和其它的一块区域合并就减1
class UnionFind{
public:
    vector<int> p;
    int count;

    UnionFind(int N){
        p.resize(N);
        for(int i = 0; i < N; ++ i) p[i] = i;
        count = 0;
    }

    int find(int x){
        if(x != p[x]) p[x] = find(p[x]);
        return p[x]; //为什么是p[x]  回溯后返回该点的父节点
    }

    int getcount() const{
        return count;
    }

    void hebin(int x, int y){
        int t1 = find(x), t2 = find(y);
        if(t1 != t2){ //两块区域
            p[t1] = t2;
            count --;
        }
    }
};

class Solution {
public:
    int dx[4] = {0,0,1,-1}, dy[4] = {1,-1,0,0};
    bool check(int x, int y, unordered_set<int>& s, int m, int n){
        return x >= 0 && x < n && y >= 0 && y < m && s.count(x * m + y);
    }
    vector<int> numIslands2(int n, int m, vector<vector<int>>& positions) {
        unordered_set<int> s(n * m);
        UnionFind unionFind(m * n);
        vector<int> res;

        for(auto & position : positions){
            int x = position[0], y = position[1];
            int idx = x * m + y;
            if(!s.count(idx)){
                s.insert(idx);
                unionFind.count ++;
                //四个方向拓展看看有没有
                for(int i = 0; i < 4; ++ i){
                    int new_x = x + dx[i], new_y = y + dy[i];
                    if(!check(new_x, new_y, s, m, n)) continue;
                    int new_idx = new_x * m + new_y;
                    if(s.count(new_idx)){ //可能合并
                        int t1 = unionFind.find(new_idx);
                        int t2 = unionFind.find(idx);
                        //当两个的父节点不一样的时候尝试合并 
                        //如果能成功合并的话count-- 表示两个区域合并
                        if(t1 != t2){
                            unionFind.hebin(idx, new_idx);
                        }
                    }
                }
            }
            res.emplace_back(unionFind.getcount());
        }
        
        return res;
    }
};
```

