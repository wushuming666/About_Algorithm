## 一. 总览

打炸了

![](https://i.bmp.ovh/imgs/2022/05/01/ad968bba33d3ddc5.png)

## 二. 代码

### T1

一开始没有思路。想了想和贪心挂钩

```cpp
//小于后面的数字 删去     不然删去最后一个
class Solution {
public:
    string removeDigit(string s, char d) {
        int n = s.size();
        int idx;
        for(int i = 0; i < n; i ++ ){
            if(s[i] == d){
                if(i == n - 1) return s.substr(0, n - 1);
                else if(s[i + 1] > s[i]) return s.substr(0, i) + s.substr(i + 1, n);
                idx = i;
            }
        }
        return s.substr(0, idx) + s.substr(idx + 1, n);
    }
};

```

### T2

自定义排序

```cpp
#define x first
#define y second
typedef pair<int, int> PII;
class Solution {
public:
    vector<PII> a;
    int minimumCardPickup(vector<int>& cards) {
        int n = cards.size();
        for(int i = 0; i < n; i ++){
            a.emplace_back(cards[i], i); //val idx
        }

        sort(a.begin(), a.end(), [](PII& t1, PII& t2){
            if(t1.x != t2.x) return t1.x < t2.x;
            return t1.y < t2.y;
        });

        int minn = 1e9;
        for(int i = 1; i < n; i ++){
            if(a[i].x == a[i-1].x) minn = min(minn, a[i].y - a[i-1].y + 1);
        }
        
        return minn == 1e9 ? -1 : minn;
    }
};

```

### T3

数组长度 200 。一开始看到后没有太强的注意，想着用数学组合的方法写。其实这就是个哈希表去重。

可以将数字转成字符串存起来。转换字符串的时候二重循环里面写了个循环、导致TLE。然后用到字符串哈希的思想、用ULL存数字。

比赛时的代码：

```cpp
typedef unsigned long long ULL;
//模拟
class Solution {
public:    
    int MOD = 13331;
    int countDistinct(vector<int>& nums, int k, int p) {
        vector<int> pre;
        int n = nums.size();
        pre.resize(n + 1);
        for(int i = 1; i <= n; i ++)
        {
            pre[i] = pre[i-1] + (nums[i-1] % p == 0);
        }
        //for(auto i : pre) cout << i << ' ';
        unordered_set<ULL> hash;
        for(int i = 0; i < n; i ++)
        {
            for(int j = 1; j <= n; j ++)
            {
                if(i + j > n) break;
                if(pre[i + j] - pre[i] > k) break;
                
                //string s;
                //for(int k = i; k < i + j; k ++) s += to_string(nums[k]), s += " ";
                ULL s = 0;
                for(int k = i; k < i + j; k ++) s *= MOD, s += nums[k];
                
                hash.insert(s);
            }
        }
        
        return hash.size();
    }
};
```

写出来后小伙伴说我多写了一重循环。现在是赛后了，去掉里面的循环再写一次：

```cpp
typedef unsigned long long ULL;
//模拟
class Solution {
public:    
    int MOD = 13331;
    int countDistinct(vector<int>& nums, int k, int p) {
        vector<int> pre;
        int n = nums.size();
        pre.resize(n + 1);
        for(int i = 1; i <= n; i ++)
        {
            pre[i] = pre[i-1] + (nums[i-1] % p == 0);
        }
        //for(auto i : pre) cout << i << ' ';
        unordered_set<string> hash;
        for(int i = 0; i < n; i ++)
        {
            string s;
            for(int j = i + 1; j <= n; j ++)
            {
                if(pre[j] - pre[i] > k) break;
                s += to_string(nums[j - 1]); 
                s += " ";       
                hash.insert(s);
            }
        }
        
        return hash.size();
    }
};

```

### T4

比赛的时候只想到了枚举滑动窗口的长度。

昨天看了看灵佬的题解没有看懂。今天下午又看看似乎看懂了。

1. 如果一个字符第一次出现，出现的下标在 $i$ 。那它前面的所有以它结尾的字符串的总引力都会加上1，再加上它自己，一共是 $i + 1$
2. 如果一个字符出现在 $i$，它前面一个出现的下标是 $j$。那么加上 $j - i$

代码：

```cpp
typedef long long LL;
class Solution {
public:
    long long appealSum(string s) {
        int n = s.size();
        vector<int> idx;
        idx.resize(26, -1);

        LL res = 0;
        LL tmp = 0;
        for(int i = 0; i < n; i ++)
        {
            int t = idx[s[i] - 'a'];
            tmp += i - t;
            res += tmp;
            idx[s[i] - 'a'] = i;
        }

        return res;
    }
};
```

